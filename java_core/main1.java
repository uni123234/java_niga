package java_core;

public class main1 {
  public static void main(String[] args) {

  }

  public String toBinaryString(int value) {
    // Write code below this line

    StringBuilder binaryResult = new StringBuilder();
    if (value == 0) {
      return "0";
    }
    while (value > 0) {
      binaryResult.append((value % 2));
      value >>= 1;
    }

    return binaryResult.reverse().toString();
    // Write code above this line
  }

  public static int getDoubledNumber(int number) {
    return number << 1;
  }

  public boolean executeExpression(int a, int b) {
    return (a != 0) && (b / a == 2);
  }

  public boolean isFalse(boolean a, boolean b, boolean c, boolean d) {
    return a && b || c && (!d || a); // place parentheses here
  }


}

/*
 * Десяткові числа Десяткова система числення, яку також називають позиційною системою числення з
 * основою 10, є найпоширенішою системою числення, що використовується в повсякденному житті. Вона
 * називається позиційною, оскільки значення кожної цифри в числі залежить від її позиції.
 * 
 * Розглянемо 125 в десятковій системі числення. Це число можна представити як суму добутків кожної
 * цифри на 10, піднесене до степеня, що відповідає її позиції зправа наліво, починаючи з нуля.
 * Отже, ми маємо:
 * 
 * Цифра "5" стоїть на позиції 0, що означає ( 5 \times 10^0 ) Цифра "2" стоїть на позиції 1, що
 * означає ( 2 \times 10^1 ) Цифра "1" стоїть на позиції 2, що означає ( 1 \times 10^2 ) Коли ми
 * складаємо ці значення, отримуємо загальне число:
 * 
 * 125 = 1 * 100 + 2 * 10 + 5 * 1
 * 
 * або
 * 
 * 125 = 1 * 10^2 + 2 * 10^1 + 5 * 10^0
 * 
 * Таким чином, кожна цифра впливає на загальне значення числа залежно від її місця в числі.
 */

/*
 * Робота з бітами Перетворення десяткового числа у двійкове Щоб перетворити десяткове число у
 * двійкове, виконай наступні кроки:
 * 
 * Поділи десяткове число на 2 та запиши остачу. Поділи частку, отриману на попередньому кроці, на 2
 * та запиши остачу. Повторюй попередній крок (2) доки частка не стане 0. Запиши остачі від ділення,
 * отримані на попередніх кроках, у зворотному порядку. Приклад перетворення десяткового числа 23 у
 * двійкове:
 * 
 * Десяткове число: 23
 * 
 * 23 % 2 = 11 з остачею 1 11 % 2 = 5 з остачею 1 5 % 2 = 2 з остачею 1 2 % 2 = 1 з остачею 0 1 % 2
 * = 0 з остачею 1
 * 
 * Двійкове число: 10111
 */

/*
 * Перетворення двійкового числа в десяткове Щоб перетворити двійкове число в десяткове, виконай
 * наступні кроки:
 * 
 * Запиши цифри двійкового числа справа наліво. Кожну цифру помнож на відповідний ступінь 2,
 * починаючи з 2^0 для крайньої правої цифри. Підсумуй отримані добутки. Приклад перетворення
 * двійкового числа 10111 у десяткове:
 * 
 * Двійкове число: 10111
 * 
 * 1 * 2^0 = 1 1 * 2^1 = 2 1 * 2^2 = 4 0 * 2^3 = 0 1 * 2^4 = 16
 * 
 * Десяткове число: 16 + 0 + 4 + 2 + 1 = 23
 */

/*
 * Переповнення Іноді при виконанні операцій (наприклад, множення або ділення чисел) результат може
 * вийти за межі свого діапазону. Це називається переповненням (overflow). Воно відбувається, коли
 * результат занадто великий або занадто малий. Переповнення слід уникати, бо воно може призвести до
 * неочікуваної роботи додатка.
 * 
 * Розглянемо такий приклад:
 * 
 * byte x = 127; // Maximum value for a byte x++; // Incrementing the value of x by 1
 * 
 * System.out.println(x); // -128
 * 
 * Початкове значення x є максимальним, яке може бути записано до змінної типу byte (127). Коли ми
 * збільшили x на 1, змінна переповнилась та повернулась до мінімального значення типу byte (-128).
 * Це приклад негативного (negative) переповнення.
 * 
 * Подібним чином працює і позитивне (positive) переповнення — воно може виникнути коли результат
 * операцій перевищує максимальне значення типу даних змінної.
 */

/*
 * Перетворення негативного числа з десяткової системи числення в двійкову Розглянемо покроковий
 * алгоритм перетворення негативного десяткового числа типу byte, наприклад -12, у двійкову систему
 * числення.
 * 
 * Цей алгоритм використовує так званий "доповнювальний до двох" (two's complement) метод для
 * представлення від'ємних чисел у двійковій системі числення.
 * 
 * Крок 1: Представлення десяткового числа у двійковій формі Перетворіть позитивне значення
 * негативного числа на двійкову форму. Наприклад, для -12 спочатку беремо 12 в десятковій системі і
 * перетворюємо його в двійкову систему: 12 в десятковій -> 1100 в двійковій.
 * 
 * Крок 2: Приведення двійкового числа до формату byte Доповніть двійкове число до 8 біт (так як тип
 * byte утворює 8-бітове число) додаючи нулі спереду: 1100 -> 00001100.
 * 
 * Крок 3: Інвертування бітів Змініть всі 0 на 1 і всі 1 на 0 (тобто виконайте операцію NOT для
 * кожного біта): 00001100 -> 11110011.
 * 
 * Крок 4: Додавання одиниці Додайте 1 до отриманого числа (тобто виконайте операцію двійкового
 * додавання): 11110011 + 1 = 11110100.
 * 
 * Крок 5: Результат Результатом є двійкове представлення -12 у форматі byte: -12 в десятковій
 * системі -> 11110100 в двійковій.
 */

/*
 * Побітові операції Побітові операції використовують для дій з окремими бітами чисел типу byte,
 * short, int та long. Вони обробляють числа як послідовність бітів. Ось побітові операції, які
 * можна виконати в Java:
 * 
 * Побітове AND (&) повертає 1, якщо обидва біти дорівнюють 1, інакше — 0.
 * 
 * Побітове OR (|) повертає 1, якщо один із бітів дорівнює 1, інакше — 0.
 * 
 * Побітове XOR (^) повертає 1, якщо біти відрізняються (один біт дорівнює 0, а інший дорівнює 1),
 * інакше — 0.
 * 
 * Побітове NOT (~) інвертує біти операнда, перетворюючи кожен 0 на 1, а кожну 1 на 0. Це унарний
 * оператор.
 * 
 * Лівий зсув (<<) зсуває біти лівого операнда вліво на кількість позицій, визначену правим
 * операндом. Крайні ліві біти відкидаються, а крайні праві біти заповнюються нулями.
 * 
 * Правий зсув (>>) зсуває біти лівого операнда праворуч на кількість позицій, визначену правим
 * операндом. Крайні праві біти відкидаються, а крайні ліві біти заповнюються бітом знака (крайній
 * лівий біт лівого операнда).
 * 
 * Беззнаковий правий зсув (>>>) зсуває біти лівого операнда праворуч на кількість позицій,
 * визначену правим операндом. Крайні праві біти відкидаються, а крайні ліві біти заповнюються
 * нулями.
 * 
 * A B A|B A&B A^B ~A 0 0 0 0 0 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 1 1 0 0 Приклад, який демонструє
 * побітові операції:
 * 
 * int a = 9; // Binary: 00001001 int b = 5; // Binary: 00000101
 * 
 * int bitwiseAnd = a & b; // Binary: 00000001 (1) int bitwiseOr = a | b; // Binary: 00001101 (13)
 * int bitwiseXor = a ^ b; // Binary: 00001100 (12) int bitwiseNotA = ~a; // Binary: 11110110 (-10)
 * int leftShift = a << 2; // Binary: 00100100 (36) int rightShift = a >> 2; // Binary: 00000010 (2)
 * int unsignedRightShift = a >>> 2; // Binary: 00000010 (2)
 * 
 * Зверни увагу: у прикладі ми використали тип даних int, але ті ж самі операції також можна
 * виконати з типами byte, short та long.
 */

/*
 * Умовні (логічні) операції Логічні операції виконуються над булевими значеннями (true або false)
 * та повертають результат такого ж типу. У Java доступні наступні логічні операції:
 * 
 * Логічне AND (&&) повертає true, якщо обидва операнди виразу мають значення true, інакше — false.
 * Якщо лівий операнд має значення false, то результат виразу також буде false.
 * 
 * OR (||) повертає true, якщо принаймні один з операндів виразу дорівнює true, інакше — false. Якщо
 * лівий операнд має значення true, то результат виразу також буде true.
 * 
 * NOT (!) повертає протилежне значення операнда. Якщо операнд має значення true, він повертає
 * значення false, і навпаки.
 * 
 * Якщо у твоєму виразі є декілька логічних операцій, то вони виконуватимуться в такому порядку: !
 * -> && -> ||.
 * 
 * Приклад логічних операцій:
 * 
 * boolean a = true; boolean b = false; boolean c = true;
 * 
 * boolean result1 = a && b; // false boolean result2 = a || b; // true boolean result3 = !a; //
 * false boolean result4 = a && b || c; // true boolean result5 = !a && b && c; // false
 * 
 * Щоб згрупувати декілька логічних виразів, можна використати дужки. Але зауваж, що вони мають
 * найвищий пріоритет:
 * 
 * boolean a = true; boolean b = true; boolean c = false; boolean d = false;
 * 
 * boolean result1 = a && b || c && d; // true boolean result2 = a && (b || c) && d; // false
 * 
 * Побітові операції та логічні значення Побітові операції & та | можна використовувати з логічними
 * значеннями, наприклад:
 * 
 * boolean result1 = true & false; // false boolean result2 = true | false; // true
 * 
 * Відмінність логічних та побітових операцій полягає в тому, що при використанні && та || ми не
 * порівнюємо праву частину виразу, якщо з перевірки лівої частини ми знаємо результат, наприклад:
 * 
 * boolean firstCondition = false; boolean secondCondition = true;
 * 
 * if (firstCondition && secondCondition) { // `secondCondition` won't be taken into consideration
 * // Block code }
 * 
 * Отже, якщо існує потреба уникнути оцінки другого операнда, коли результат можна визначити
 * виключно на основі першого операнда, рекомендується використовувати логічні операції && та ||.
 * 
 * Зверни увагу: & та | можна використовувати як з числами, так і з логічними значеннями, а && та ||
 * — лише з логічними значеннями.
 */
